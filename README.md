# Python in a Nutshell

---

Table of Contents

- [1 Python Interpreter](#python-interpreter)
- [2 Core Python Language and Build-ins](#core-python-language-and-built-ins)

## Python Interpreter

Python frequently used command-line options:

- `-B` - Don’t save compiled bytecode files to disk (PYTHONDONTWRITEBYTECODE)
- `-c` - Specifies Python statements as part of the command line
- `-E` - Ignores all environment variables
- `-h` - Prints a full list of options and summary help, then terminates
- `-i` - Runs an interactive session after the file or command runs (PYTHONINSPECT)
- `-m` - Specifies a Python module or package to run as the main script
- `-O` - Optimizes generated bytecode (PYTHONOPTIMIZE)—note that this is an uppercase letter O, not the digit0
- `-OO` - Like -O, but also removes documentation strings from the bytecode
- `--Q arg` - Controls the behavior of division operator / on integers (v2 only)
- `-S` - Omits the implicit import site on startup
- `-t` - Issues warnings about inconsistent tab usage (-tt issues errors)
- `-u` - Uses unbuffered binary files for standard output and standard error (PYTHONUNBUFFERED)
- `-v` - Verbosely traces module import and cleanup actions (PYTHONVERBOSE)
- `-V` - Prints the Python version number, then terminates
- `-W arg` - Adds an entry to the warnings filter
- `-x` - Excludes (skips) the first line of the main script’s source

Use `-i` when you want to get an interactive session immediately after running some script, with top-level variables still intact and available for inspection. You do not need `-i` for normal interactive sessions, although it does no harm. `-t` and `-tt` ensure that you use tabs and spaces consistently in Python sources

#### Interactive sessions

When you run python without a script argument, Python starts an interactive ses‐ sion and prompts you to enter Python statements or expressions. Interactive ses‐ sions are useful to explore, to check things out, and to use Python as a powerful, extensible interactive calculator.

When you enter a complete statement, Python executes it. When you enter a com‐ plete expression, Python evaluates it. If the expression has a result, Python outputs a string representing the result and also assigns the result to the variable named \_ (a single underscore) so that you can immediately use that result in another expres‐ sion. The prompt string is >>> when Python expects a statement or expression and ... when a statement or expression has been started but not completed. In par‐ ticular, Python prompts you with ... when you have opened a parenthesis on a pre‐ vious line and have not closed it yet.

#### Running Python Programs

Whatever tools you use to produce your Python application, you can see your appli‐ cation as a set of Python source files, which are normal text files. A script is a file that you can run directly. A module is a file that you can import to provide functionality to other files or to interactive sessions. A Python file can be both a module (exposing functionality when imported) and a script (suit‐ able for being run directly). A useful and widespread convention is that Python files that are primarily intended to be imported as modules, when run directly, should execute some simple self-test operations.

The Python interpreter automatically compiles Python source files as needed. Python source files normally have the extension .py. In v2, Python saves the com‐ piled bytecode file for each module in the same directory as the module’s source, with the same basename and extension .pyc (or .pyo when you run Python with option -O). In v3, Python saves the compiled bytecode in subdirectory \_**\_pycache\_\_** of the directory containing the module’s source, with a version-specific extension, and annotated to denote optimization level.

Run Python with option `-B` to avoid saving compiled bytecode to disk, which can be handy when you import modules from a read-only disk. Also, Python does not save the compiled bytecode form of a script when you run the script directly; rather, Python recompiles the script each time you run it. Python saves bytecode files only for modules you import. It automatically rebuilds each module’s bytecode file when‐ ever necessary

You can run Python code interactively with the Python interpreter or an IDE. Nor‐ mally, however, you initiate execution by running a top-level script. To run a script, give its path as an argument to python. Depending on your operating system, you can invoke python directly from a shell script or command file. On Unix-like systems, you can make a Python script directly executable by setting the file’s permission bits `x` and `r` and beginning the script with a so-called `shebang` line, which is a first line such as:

`#!/usr/bin/env python`

or some other line starting with `#!` followed by a path to the python interpreter pro‐ gram, in which case you can optionally add a single word of options, for example:

`#!/usr/bin/python -O`

## Core Python Language and Built ins

#### Tokens

Python breaks each logical line into a sequence of elementary lexical components known as tokens. Each token corresponds to a substring of the logical line. The normal token types are identifiers, keywords, operators, delimiters, and literals, which we cover in the following sections. You may freely use whitespace between tokens to separate them. Some whitespace separation is necessary between logically adjacent identifiers or keywords; otherwise, Python would parse them as a single, longer identifier. For example, `ifx` is a single identifier; to write the keyword `if` followed by the identifier `x`, you need to insert some whitespace (e.g., `if x`).

##### Identifiers

An identifier is a name used to specify a variable, function, class, module, or other object. An identifier starts with a letter.

Normal Python style is to start class names with an uppercase letter, and other identifiers with a lowercase letter. Starting an identifier with a single leading underscore indicates by convention that the identifier is meant to be private. Starting an identi‐ fier with two leading underscores indicates a strongly private identifier; if the identi‐ fier also ends with two trailing underscores, however, this means that the identifier is a language-defined special name.

##### Keywords

Python has keywords (31 of them in v2; 33 in v3), which are identifiers that Python reserves for special syntactic uses.

1. `and` - A logical operator
2. `as` - To create an alias
3. `assert` - For debugging
4. `break` - To break out of a loop
5. `class` - To define a class
6. `continue` - To continue to the next iteration of a loop
7. `def` - To define a function
8. `del` - To delete an object
9. `elif` - Used in conditional statements, same as else if
10. `else` - Used in conditional statements
11. `except` - Used with exceptions, what to do when an exception occurs
12. `False` - Boolean value, result of comparison operations
13. `finally` - Used with exceptions, a block of code that will be executed no matter if there is an exception or not
14. `for` - To create a for loop
15. `from` - To import specific parts of a module
16. `global` - To declare a global variable
17. `if` - To make a conditional statement
18. `import` - To import a module
19. `in` - To check if a value is present in a list, tuple, etc.
20. `is` - To test if two variables are equal
21. `lambda` - To create an anonymous function
22. `None` - Represents a null value
23. `nonlocal` - To declare a non-local variable
24. `not` - A logical operator
25. `or` - A logical operator
26. `pass` - A null statement, a statement that will do nothing
27. `raise` - To raise an exception
28. `return` - To exit a function and return a value
29. `True` - Boolean value, result of comparison operations
30. `try` - To make a try...except statement
31. `while` - To create a while loop
32. `with` - Used to simplify exception handling
33. `yield` - To end a function, returns a generator
