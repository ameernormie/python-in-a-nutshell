# Python in a Nutshell

---

Table of Contents

- [1 Python Interpreter](#python-interpreter)
- [2 Core Python Language and Build-ins](#core-python-language-and-built-ins)

## Python Interpreter

Python frequently used command-line options:

- `-B` - Don’t save compiled bytecode files to disk (PYTHONDONTWRITEBYTECODE)
- `-c` - Specifies Python statements as part of the command line
- `-E` - Ignores all environment variables
- `-h` - Prints a full list of options and summary help, then terminates
- `-i` - Runs an interactive session after the file or command runs (PYTHONINSPECT)
- `-m` - Specifies a Python module or package to run as the main script
- `-O` - Optimizes generated bytecode (PYTHONOPTIMIZE)—note that this is an uppercase letter O, not the digit0
- `-OO` - Like -O, but also removes documentation strings from the bytecode
- `--Q arg` - Controls the behavior of division operator / on integers (v2 only)
- `-S` - Omits the implicit import site on startup
- `-t` - Issues warnings about inconsistent tab usage (-tt issues errors)
- `-u` - Uses unbuffered binary files for standard output and standard error (PYTHONUNBUFFERED)
- `-v` - Verbosely traces module import and cleanup actions (PYTHONVERBOSE)
- `-V` - Prints the Python version number, then terminates
- `-W arg` - Adds an entry to the warnings filter
- `-x` - Excludes (skips) the first line of the main script’s source

Use `-i` when you want to get an interactive session immediately after running some script, with top-level variables still intact and available for inspection. You do not need `-i` for normal interactive sessions, although it does no harm. `-t` and `-tt` ensure that you use tabs and spaces consistently in Python sources

#### Interactive sessions

When you run python without a script argument, Python starts an interactive ses‐ sion and prompts you to enter Python statements or expressions. Interactive ses‐ sions are useful to explore, to check things out, and to use Python as a powerful, extensible interactive calculator.

When you enter a complete statement, Python executes it. When you enter a com‐ plete expression, Python evaluates it. If the expression has a result, Python outputs a string representing the result and also assigns the result to the variable named `_` (a single underscore) so that you can immediately use that result in another expres‐ sion. The prompt string is >>> when Python expects a statement or expression and ... when a statement or expression has been started but not completed. In par‐ ticular, Python prompts you with ... when you have opened a parenthesis on a pre‐ vious line and have not closed it yet.

#### Running Python Programs

Whatever tools you use to produce your Python application, you can see your appli‐ cation as a set of Python source files, which are normal text files. A script is a file that you can run directly. A module is a file that you can import to provide functionality to other files or to interactive sessions. A Python file can be both a module (exposing functionality when imported) and a script (suit‐ able for being run directly). A useful and widespread convention is that Python files that are primarily intended to be imported as modules, when run directly, should execute some simple self-test operations.

The Python interpreter automatically compiles Python source files as needed. Python source files normally have the extension .py. In v2, Python saves the com‐ piled bytecode file for each module in the same directory as the module’s source, with the same basename and extension .pyc (or .pyo when you run Python with option -O). In v3, Python saves the compiled bytecode in subdirectory \_**\_pycache\_\_** of the directory containing the module’s source, with a version-specific extension, and annotated to denote optimization level.

Run Python with option `-B` to avoid saving compiled bytecode to disk, which can be handy when you import modules from a read-only disk. Also, Python does not save the compiled bytecode form of a script when you run the script directly; rather, Python recompiles the script each time you run it. Python saves bytecode files only for modules you import. It automatically rebuilds each module’s bytecode file when‐ ever necessary

You can run Python code interactively with the Python interpreter or an IDE. Nor‐ mally, however, you initiate execution by running a top-level script. To run a script, give its path as an argument to python. Depending on your operating system, you can invoke python directly from a shell script or command file. On Unix-like systems, you can make a Python script directly executable by setting the file’s permission bits `x` and `r` and beginning the script with a so-called `shebang` line, which is a first line such as:

`#!/usr/bin/env python`

or some other line starting with `#!` followed by a path to the python interpreter pro‐ gram, in which case you can optionally add a single word of options, for example:

`#!/usr/bin/python -O`

## Core Python Language and Built ins

#### Tokens

Python breaks each logical line into a sequence of elementary lexical components known as tokens. Each token corresponds to a substring of the logical line. The normal token types are identifiers, keywords, operators, delimiters, and literals, which we cover in the following sections. You may freely use whitespace between tokens to separate them. Some whitespace separation is necessary between logically adjacent identifiers or keywords; otherwise, Python would parse them as a single, longer identifier. For example, `ifx` is a single identifier; to write the keyword `if` followed by the identifier `x`, you need to insert some whitespace (e.g., `if x`).

##### Identifiers

An identifier is a name used to specify a variable, function, class, module, or other object. An identifier starts with a letter.

Normal Python style is to start class names with an uppercase letter, and other identifiers with a lowercase letter. Starting an identifier with a single leading underscore indicates by convention that the identifier is meant to be private. Starting an identi‐ fier with two leading underscores indicates a strongly private identifier; if the identi‐ fier also ends with two trailing underscores, however, this means that the identifier is a language-defined special name.

##### Keywords

Python has keywords (31 of them in v2; 33 in v3), which are identifiers that Python reserves for special syntactic uses.

1. `and` - A logical operator
2. `as` - To create an alias
3. `assert` - For debugging
4. `break` - To break out of a loop
5. `class` - To define a class
6. `continue` - To continue to the next iteration of a loop
7. `def` - To define a function
8. `del` - To delete an object
9. `elif` - Used in conditional statements, same as else if
10. `else` - Used in conditional statements
11. `except` - Used with exceptions, what to do when an exception occurs
12. `False` - Boolean value, result of comparison operations
13. `finally` - Used with exceptions, a block of code that will be executed no matter if there is an exception or not
14. `for` - To create a for loop
15. `from` - To import specific parts of a module
16. `global` - To declare a global variable
17. `if` - To make a conditional statement
18. `import` - To import a module
19. `in` - To check if a value is present in a list, tuple, etc.
20. `is` - To test if two variables are equal
21. `lambda` - To create an anonymous function
22. `None` - Represents a null value
23. `nonlocal` - To declare a non-local variable
24. `not` - A logical operator
25. `or` - A logical operator
26. `pass` - A null statement, a statement that will do nothing
27. `raise` - To raise an exception
28. `return` - To exit a function and return a value
29. `True` - Boolean value, result of comparison operations
30. `try` - To make a try...except statement
31. `while` - To create a while loop
32. `with` - Used to simplify exception handling
33. `yield` - To end a function, returns a generator

##### Operators

```
+ - * / % ** // << >> & | ^ ~ < <= > >= < > != ==
```

##### Delimiters

Python uses the following characters and combinations as delimiters in expressions, list, dictionary, and set literals, and various statements, among other purposes:

```
(  )   [  ]   {  }
,  :  .  `   =  ;  @
+=  -=  *=  /= //=  %=
&=  |=  ^=  >>=  <<=  **=
```

##### Statements

You can look at a Python source file as a sequence of simple and compound statements. Unlike some other languages, Python has no “declarations” or other top-level syntax elements: just statements.

##### Data Types

The operation of a Python program hinges on the data it handles. Data values in Python are known as objects; each object, AKA value, has a type. An object’s type determines which operations the object supports (in other words, which operations you can perform on the value). The type also determines the object’s attributes and items (if any) and whether the object can be altered. An object that can be altered is known as a mutable object, while one that cannot be altered is an immutable object.

The built-in type(obj) accepts any object as its argument and returns the type object that is the type of obj. The built-in function `isinstance(obj, type)` returns `True` when object obj has type type (or any subclass thereof ); otherwise, it returns `False`.

##### Numbers

The built-in numeric types in Python include integers (int and long, in v2; in v3, there’s no distinction between kinds of integers), floating-point numbers, and complex numbers.
`All numbers in Python are immutable objects; therefore, when you perform an operation on a number object, you produce a new number object`

##### Integer Numbers

Integer literals can be decimal, binary, octal, or hexadecimal. A `decimal literal` is a sequence of digits in which the `first digit is nonzero`. A `binary literal` is `0b followed by a sequence of binary digits (0 or 1)`. An `octal literal`, in v2 only, can be 0 followed by a sequence of `octal digits (0 to 7)`. This syntax can be quite misleading for the reader, and we do not recommend it; rather, use `0o followed by a sequence of octal digits`, which works in both v2 and v3 and does not risk misleading the reader. A `hexadecimal literal` is `0x followed by a sequence of hexadecimal digits (0 to 9 and A to F, in either upper- or lowercase)`. For example:

```python
1, 23, 3493             # Decimal integer literals
0b010101, 0b110010      # Binary integer literals
0o1, 0o27, 0o6645       # Octal integer literals
0x1, 0x17, 0xDA5        # Hexadecimal integer literals
```

##### Floating-point numbers

A floating-point literal is a sequence of decimal digits that includes a decimal point (.), an exponent suffix (an e or E, optionally followed by + or -, followed by one or more digits), or both. The leading character of a floating-point literal cannot be e or E; it may be any digit or a period (.). For example:

```python
0., 0.0, .0, 1., 1.0, 1e0, 1.e0, 1.0e0 # Floating-point literals
```

##### Complex numbers

A complex number is made up of two floating-point values, one each for the real and imaginary parts. You can access the parts of a complex object `z` as read-only attributes `z.real` and `z.imag`. You can specify an imaginary literal as a floating- point or decimal literal followed by a j or J:

```python
0j, 0.j, 0.0j, .0j, 1j, 1.j, 1.0j, 1e0j, 1.e0j, 1.0e0j
```

The `j` at the end of the literal indicates the `square root of -1`, as commonly used in electrical engineering (some other disciplines use `i` for this purpose, but Python has chosen j. There are no other complex literals. To denote any constant complex number, add or subtract a floating-point (or integer) literal and an imaginary one. `For example, to denote the complex number that equals one, use expressions like 1+0j or 1.0+0.0j. Python performs the addition or subtraction at compile time.`

##### Underscores in numeric literals

To assist visual assessment of the magnitude of a number, from 3.6 onward numeric literals can include single underscore (\_) characters between digits or after any base specifier. As this implies, not only decimal numeric constants can benefit from this new notational freedom:

```python
# grouping decimal numbers by thousands
amount = 10_000_000.0

# grouping hexadecimal addresses by words
addr = 0xCAFE_F00D

# grouping bits into nibbles in a binary literal
flags = 0b_0011_1111_0100_1110

# same, for string conversions
flags = int('0b_1111_0000', 2)
```

##### Sequences

A sequence is an ordered container of items, indexed by integers. Python has built-in sequence types known as strings (bytes and Unicode), tuples, and lists. Library and extension modules provide other sequence types, and you can write yet others yourself

##### Iterables

A Python concept that generalizes the idea of “sequence” is that of iterables. `All sequences are iterable`: whenever we say you can use an iterable, you can in particular use a sequence (for example, a list).

`Also, when we say that you can use an iterable, we mean, usually, a bounded iterable: an iterable that eventually stops yielding items. All sequences are bounded. Itera‐ bles, in general, can be unbounded, but if you try to use an unbounded iterable without special precautions, you could produce a program that never terminates, or one that exhausts all available memory.`

##### Strings
